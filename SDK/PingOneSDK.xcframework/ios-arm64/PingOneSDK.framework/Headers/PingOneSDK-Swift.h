// Generated by Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
#ifndef PINGONESDK_SWIFT_H
#define PINGONESDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="PingOneSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSString;
@class NSError;

/// Public class that contains data of authenticate with code response
SWIFT_CLASS("_TtC10PingOneSDK20AuthenticationObject")
@interface AuthenticationObject : NSObject
/// List of users that are paired to this device. Each user object can contain the following String variables: <code>userId</code>, <code>email</code>, <code>given</code>, <code>family</code> and <code>username</code>.
@property (nonatomic, copy) NSArray<NSDictionary<NSString *, id> *> * _Nullable users;
/// String that determines if user approval is required to complete an authentication. Possible values: <code>REQUIRED</code> and <code>NOT_REQUIRED</code>
@property (nonatomic, copy) NSString * _Nullable userApproval;
/// Object for passing any data as a String from server to end-user
@property (nonatomic, copy) NSString * _Nullable clientContext;
/// String value returned from a server when a user calls an authenticate API method. Possible values: can be <code>CLAIMED</code>, <code>EXPIRED</code>, <code>DENIED</code> or <code>COMPLETED</code>
@property (nonatomic, copy) NSString * _Nullable status;
/// Approve authentication with code
/// If <code>userApproval</code> is <code>REQUIRED</code> or multiple users may approve the authentication,
/// call this method with a userId of the user, who triggered the method.
/// <ul>
///   <li>
///     Returns completionHandler: Will return status String value with one of the following values:
///     <code>COMPLETED</code> or <code>EXPIRED</code>.
///     Returns NSError in case of an error.
///   </li>
/// </ul>
/// \param userId String value of the user id, fetched from the user object.
///
- (void)approveWithUserId:(NSString * _Nonnull)userId completionHandler:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completionHandler;
/// Deny authentication with code
/// If <code>userApproval</code> is <code>REQUIRED</code> or multiple users may deny the authentication,
/// call this method with a userId of the user, who triggered the method.
/// <ul>
///   <li>
///     Returns completionHandler: Will return status String value with one of the following values:
///     <code>DENIED</code> or <code>EXPIRED</code>.
///     Returns NSError in case of an error.
///   </li>
/// </ul>
/// \param userId String value of the user id, fetched from the user object.
/// This field is not mandatory, authentication can be denied without passing this value.
///
- (void)deny:(NSString * _Nullable)userId completionHandler:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum AuthenticatorType : NSInteger;
enum AuthenticatorStatus : NSInteger;

/// AuthenticatorModel public class contains the acceptable authorization methods and its status
SWIFT_CLASS("_TtC10PingOneSDK18AuthenticatorModel")
@interface AuthenticatorModel : NSObject
/// The Authenticator type
@property (nonatomic, readonly) enum AuthenticatorType type;
/// The Authenticator status
@property (nonatomic, readonly) enum AuthenticatorStatus status;
/// Error message in case of authorization method failure
@property (nonatomic, readonly, copy) NSString * _Nullable errorCode;
/// Error code in case of authorization method failure
@property (nonatomic, readonly, copy) NSString * _Nullable errorMessage;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, AuthenticatorType, open) {
/// Unknown type of authenticator
  AuthenticatorTypeUnknown = -1,
/// Authenticator with push type
  AuthenticatorTypePush = 0,
/// Authenticator with one time passcode type
  AuthenticatorTypeOneTimePasscode = 1,
};

typedef SWIFT_ENUM(NSInteger, AuthenticatorStatus, open) {
/// Unknown authenticator status
  AuthenticatorStatusUnknown = -1,
/// Authenticator received completed status
  AuthenticatorStatusCompleted = 0,
/// Authenticator received failed status
  AuthenticatorStatusFailed = 1,
};

typedef SWIFT_ENUM(NSInteger, ErrorCode, open) {
/// Internal Error.
  ErrorCodeInternalError = 10000,
/// Device token was missing and is required to complete this action.
  ErrorCodeDeviceTokenIsMissing = 10001,
/// Remote notification isn’t from PingOne.
  ErrorCodeUnrecognizedRemoteNotification = 10002,
/// There was a server error.
  ErrorCodeServerError = 10003,
/// There was a problem with the network.
  ErrorCodeNoConnectivity = 10004,
/// There was a problem with the pairing key.
  ErrorCodePairingKey = 10005,
/// There was a problem with the bundle id.
  ErrorCodeBundleId = 10006,
/// Device may be paired in one regional data center only, and is already paired in another regional data center.
  ErrorCodePairingKeyDataCenterMismatch = 10007,
/// Device is not paired.
  ErrorCodeDeviceIsNotPaired = 10008,
/// Client confirmation delay responding to push notification, resulted in timeout.
  ErrorCodePushConfirmationTimeout = 10009,
/// Client failed to verify due to invalid one time passcode sent to the server.
  ErrorCodePasscodeNotValid = 10010,
/// Authentication code is not valid.
  ErrorCodeAuthCodeInvalid = 10011,
/// Mobile device does not comply with policy requirements.
  ErrorCodeFailedPolicyRequirements = 10012,
};



enum NotificationType : NSInteger;
@class NSNumber;

/// A Notification Object represents an authentication request via remote notification. It can be approved or denied.
SWIFT_CLASS("_TtC10PingOneSDK18NotificationObject")
@interface NotificationObject : NSObject
/// Describes the purpose of the notification.
@property (nonatomic, readonly) enum NotificationType notificationType;
/// The maximum time duration allowed from getting push till user response.
@property (nonatomic, readonly) NSInteger timeoutDuration;
/// Extra parameters are passed to the client with the push object
@property (nonatomic, readonly, copy) NSString * _Nonnull clientContext;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Approve authentication
/// \param withAuthenticationMethod The <code>String</code> is the authentication method that was used to authenticate the user on the authenticating device, for example, fpt (fingerprint), face (facial recognition) etc. Refer to the “amr” (Authentication Method Reference) values in https://tools.ietf.org/html/rfc8176/#section-2 .
///
/// \param completionHandler Will return NSError in case of an error.
///
- (void)approveWithAuthenticationMethod:(NSString * _Nullable)withAuthenticationMethod completionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
/// Approve authentication
/// \param completionHandler Will return NSError in case of an error.
///
- (void)approveWithCompletionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler SWIFT_DEPRECATED_MSG("please use approve(withAuthenticationMethod:completionHandler) instead");
/// Deny authentication
/// \param completionHandler Will return NSError in case of an error.
///
- (void)denyWithCompletionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
@end

/// Type that describes the purpose of the notification.
typedef SWIFT_ENUM(NSInteger, NotificationType, open) {
/// Notification was not recognized.
  NotificationTypeNone = -1,
/// Notification process has finished. No further action is required.
  NotificationTypeDone = 0,
/// Authentication notification that should be presented to the user and followed with the <code>approve</code> or <code>deny</code> method.
  NotificationTypeAuthentication = 1,
};


/// Public class that contains data of the One Time Passcode
SWIFT_CLASS("_TtC10PingOneSDK19OneTimePasscodeInfo")
@interface OneTimePasscodeInfo : NSObject
/// The generated passcode
@property (nonatomic, readonly, copy) NSString * _Nonnull passcode;
/// The time of expiration of the code.
/// it is provided in double format which holds the future time in milliseconds divided by 1000 to represent seconds
@property (nonatomic, readonly) double validUntil;
/// The time of creation of the passcode.
@property (nonatomic, readonly) double validFrom;
/// The total life span of the passcode since it was created until it expired. The time unit is seconds
@property (nonatomic, readonly) NSInteger timeWindowSize;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Public PairingInfo class contains data about pairing resolution
SWIFT_CLASS("_TtC10PingOneSDK11PairingInfo")
@interface PairingInfo : NSObject
/// List of authentication methods and their statuses
@property (nonatomic, copy) NSArray<AuthenticatorModel *> * _Nonnull authenticatorsArray;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PairingObject represents a pairing request that can be approved or ignored.
SWIFT_CLASS("_TtC10PingOneSDK13PairingObject")
@interface PairingObject : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Approve pairing
/// \param completionHandler Will return NSError in case of an error.
///
- (void)approveWithCompletionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler SWIFT_DEPRECATED_MSG("please use approve(completion: @escaping (_ response: PairingInfo?, _ error: NSError?) -> Void)");
/// Approve pairing
/// \param completionHandler Will return PairingInfo object containing data about pairing resolution, and NSError in case of an error.
///
- (void)approveWithCompletion:(void (^ _Nonnull)(PairingInfo * _Nullable, NSError * _Nullable))completion;
@end

@class NSData;
enum APNSDeviceTokenType : NSInteger;
@class UNNotificationCategory;

SWIFT_CLASS("_TtC10PingOneSDK7PingOne")
@interface PingOne : NSObject
/// Generate a payload string for any communication needed between the customer mobile app and the PingOne server.
/// The PingOne Native SDK returns a native payload to the customer native application.
/// The payload is a small data package created by the PingOne Native SDK component,
/// which is used as part of the device’s authorization.
///
/// throws:
/// NSError if failed to create payload.
///
/// returns:
/// The mobile payload string.
+ (NSString * _Nullable)generateMobilePayloadAndReturnError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Pair device
/// Pairs the device with the PingOne server using the <code>pairing key</code>.
/// \param pairingKey pairing key as a string.
///
///
/// returns:
/// A completionHandler object which contains an error in case the pair failed.
+ (void)pair:(NSString * _Nonnull)pairingKey completionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler SWIFT_DEPRECATED_MSG("please use pair(_ pairingKey: String, completion: @escaping (_ response: PairingInfo? , NSError?) instead");
/// Pair device
/// Pairs the device with the PingOne server using the <code>pairing key</code>.
/// \param pairingKey pairing key as a string.
///
///
/// returns:
/// a <code>completionHandler</code> which contains <code>PairingInfo</code>, a wrapper object that contains an array list with
/// authentication methods (One time passcode and Push) status.
/// In case of error <code>PairingInfo</code> will also contain <code>NSError</code>.
/// Documentation for pairing object error codes can be found <a href="https://apidocs.pingidentity.com/pingone/native-sdks/v1/api/#pingone-mobile-sdk-for-ios">here</a>
+ (void)pair:(NSString * _Nonnull)pairingKey completion:(void (^ _Nonnull)(PairingInfo * _Nullable, NSError * _Nullable))completion;
/// Pair with automatic enrollment
/// When using OpenID Connect, this is a mandatory post action method which should be executed after receiving an ID token
/// from the PingOne server. If device authorization is triggered (i.e. verification that the user’s device
/// is already paired and active), processIdToken() will return nil, indicating that authorization has completed
/// and no further action needs to be taken.
/// \param idToken The token <code>String</code> value from the OIDExternalUserAgentSession authState object.
///
///
/// returns:
/// Will return PairingObject in case further action is required,
/// such as approving the pairing. In case of an error will return NSError.
+ (void)processIdToken:(NSString * _Nonnull)idToken completionHandler:(void (^ _Nonnull)(PairingObject * _Nullable, NSError * _Nullable))completionHandler;
/// Set device remote notification token
/// Setting should be done within the <code>application:didRegisterForRemoteNotificationsWithDeviceToken</code> method
/// in the appDelegate class.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     deviceToken: The <code>Data</code> received within the <code>application:didRegisterForRemoteNotificationsWithDeviceToken</code> method.
///   </li>
///   <li>
///     type: The <code>APNSDeviceTokenType</code> enum can be <code>production</code> or <code>sandbox</code> type.
///   </li>
/// </ul>
///
/// returns:
/// NSError in case of an error.
+ (void)setDeviceToken:(NSData * _Nonnull)deviceToken type:(enum APNSDeviceTokenType)type completionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
/// Get PingOne remote notification categories
/// PingOne provides the needed categories for notification. The developer may add categories.
/// <blockquote>
/// Tip: setting UNNotificationCategory more than once results in previous settings being overwritten.
///
/// </blockquote>
///
/// returns:
/// The remote notification categories.
+ (NSSet<UNNotificationCategory *> * _Nonnull)getUNNotificationCategories SWIFT_WARN_UNUSED_RESULT;
/// Allow push notification
/// Method that will notify the server to send or not to send push messages to this device.
/// Set to false to disable SDK push notifications.
/// \param allowed a boolean that will tell the server to send push messages or not. Defaults to <code>true</code>.
///
+ (void)allowPushNotifications:(BOOL)allowed;
/// Process the remote notification received from PingOne.
/// This method sets the notification data in the SDK and and gets back a PingOne notification object.
/// \param userInfo The <code>[AnyHashable : Any]</code> received in the AppDelegate <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> method.
///
///
/// returns:
/// Will return NSError in case of an error. Will return NotificationObject in case further action is required, such as approving or denying an authentication.
+ (void)processRemoteNotification:(NSDictionary * _Nonnull)userInfo completionHandler:(void (^ _Nonnull)(NotificationObject * _Nullable, NSError * _Nullable))completionHandler;
/// Process remote notifcation action
/// Tells PingOne server to perform the custom action specified by a remote notification. Should be within userNotificationCenter(_:didReceive:withCompletionHandler:) method.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     identifier: The <code>String</code> is the response.actionIdentifier received within userNotificationCenter(_:didReceive:withCompletionHandler:) method.
///   </li>
///   <li>
///     userInfo: The <code>[AnyHashable : Any]</code> received within userNotificationCenter(_:didReceive:withCompletionHandler:) method.
///   </li>
///   <li>
///     authenticationMethod: The <code>String</code> is the authentication method that was used to authenticate the user
///     on the authenticating device, for example, fpt (fingerprint), face (facial recognition) etc.
///     Refer to the “amr” (Authentication Method Reference) values <a href="https://tools.ietf.org/html/rfc8176/#section-2">here</a>
///   </li>
/// </ul>
///
/// returns:
/// completionHandler that will contain NSError in case of an error.
/// NotificationObject will be returned in case an action is required.
+ (void)processRemoteNotificationAction:(NSString * _Nonnull)identifier authenticationMethod:(NSString * _Nullable)authenticationMethod forRemoteNotification:(NSDictionary * _Nonnull)userInfo completionHandler:(void (^ _Nonnull)(NotificationObject * _Nullable, NSError * _Nullable))completionHandler;
/// Get info
/// Returns all the paired users from the PingOne server.
///
/// returns:
/// a completionHandler will return NSError in case of an error.
/// Will return an array with information on all the paired users.
+ (void)getInfo:(void (^ _Nonnull)(NSDictionary<NSString *, id> * _Nullable, NSError * _Nullable))completionHandler;
/// Authenticate with code
/// PingOne SDK provides an ability to authenticate via scanning the QR code.
/// The retrieved value should be passed to the PingOne SDK using the following API method.
/// \param authCode String value of the authentication code, parsed from QR or manual input.
///
///
/// returns:
/// a completionHandler that contains <code>authenticationObject</code>: users list array, clientContext object,
/// userApproval String and status String. In case of an error will return NSError.
+ (void)authenticate:(NSString * _Nonnull)authCode completionHandler:(void (^ _Nonnull)(AuthenticationObject * _Nullable, NSError * _Nullable))completionHandler;
/// Get one time passcode
/// Requests the SDK to provide a one time passcode for authentication.
///
/// returns:
/// a completionHandler that contains OneTimePasscodeInfo object.
/// It will contain all the data of the one time passcode if available.
/// In case of an error will return NSError.
+ (void)getOneTimePasscode:(void (^ _Nonnull)(OneTimePasscodeInfo * _Nullable, NSError * _Nullable))completionHandler;
/// Process remote notification action
/// Tells PingOne server to perform the custom action specified by a remote notification. Should be within userNotificationCenter(_:didReceive:withCompletionHandler:) method.
/// \param identifier The <code>String</code> is the response.actionIdentifier received within userNotificationCenter(_:didReceive:withCompletionHandler:) method.
///
/// \param userInfo The <code>[AnyHashable : Any]</code> received within userNotificationCenter(_:didReceive:withCompletionHandler:) method.
///
///
/// returns:
/// a completionHandler will return NSError in case of an error.
/// NotificationObject will be returned in case an action is required.
+ (void)processRemoteNotificationAction:(NSString * _Nonnull)identifier forRemoteNotification:(NSDictionary * _Nonnull)userInfo completionHandler:(void (^ _Nonnull)(NotificationObject * _Nullable, NSError * _Nullable))completionHandler SWIFT_DEPRECATED_MSG("please use processRemoteNotificationAction(identifier:authenticationMethod:userInfo) instead");
/// Remove PingOne local data
/// One-sided remove data method for development use only.
/// <blockquote>
/// Warning: Using this method will remove the trusted connection between the iOS SDK and the PingOne server
/// server in a one sided manner, where only the iOS side will be removed.
/// This method should not be used when logging out of your account.
/// This method should only be used in development.
///
/// </blockquote>
+ (void)removePingOneLocalData;
/// The developer can decide if the device will stay paired after app reinstallation. This method should only be called once.
/// \param stayPaired The <code>Bool</code> value. <code>true</code> to stay paired. Defaults to <code>false</code>.
///
+ (void)setDevicePairedAfterReinstall:(BOOL)stayPaired;
/// Send logs
/// This method will send logs to the PingOne server.
/// <blockquote>
/// Tip: The supportId can then be forwarded to the Ping Identity support team to review the logs.
///
/// </blockquote>
///
/// returns:
/// will return NSError in case of an error.
/// A supportId will be returned when the logs have been sent successfully.
+ (void)sendLogsWithCompletionHandler:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Type that describes the APNS environment.
/// It is possible to establish a connection between the PingOne server and one of the following Apple servers:
/// Development (<code>sandbox</code>) or <code>production</code> server.
typedef SWIFT_ENUM(NSInteger, APNSDeviceTokenType, open) {
/// Production environment.
  APNSDeviceTokenTypeProduction = 0,
/// Sandbox environment.
  APNSDeviceTokenTypeSandbox = 1,
};

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif
